diff --git a/code/assemble.cpp b/../double_diffusion_2/code/assemble.cpp
index 14381f40..6c17c1f3 100644
--- a/code/assemble.cpp
+++ b/../double_diffusion_2/code/assemble.cpp
@@ -1,5 +1,6 @@
 #include "header.h"
 
+//Rotational functions
 double r_f(const Vector &x);
 void rot_f(const Vector &x, DenseMatrix &f);
 void zero_f(const Vector &x, Vector &f);
@@ -25,10 +26,9 @@ void Artic_sea::assemble_system(){
 
     oper_T = new Conduction_Operator(config, *fespace, dim, pmesh->bdr_attributes.Max(), block_true_offsets, X);
 
-    //Reocver initial conditions
+    //Recover initial conditions
     theta->Distribute(&(X.GetBlock(0)));
     phi->Distribute(&(X.GetBlock(1)));
-    Theta = theta->GetTrueDofs();
 
     //Calculate phases
     for (int ii = 0; ii < phase->Size(); ii++){
@@ -36,19 +36,6 @@ void Artic_sea::assemble_system(){
         (*phase)(ii) = 0.5*(1 + tanh(5*config.invDeltaT*((*theta)(ii) - T_f)));
     }
 
-    //Define solution psi
-    x_psi = new ParGridFunction(fespace);
-    x_v = new ParGridFunction(fespace_v);
-    x_w = new ParGridFunction(fespace);
-    X_Psi = new HypreParVector(fespace);
-
-    flow_oper = new Flow_Operator(config, *fespace, *fespace_v, dim, pmesh->bdr_attributes.Max(), block_true_offsets, Theta);
-    flow_oper->Solve(config, Theta, dim, pmesh->bdr_attributes.Max());
-    X_Psi = (flow_oper->GetStream()).GetTrueDofs();
-    (*x_psi) = flow_oper->GetStream();
-    (*x_w) = flow_oper->GetVorticity();
-    oper_T->UpdateVelocity(*X_Psi, x_v);
-
     //Set the ODE solver type
     switch (config.ode_solver_type){
         // MFEM explicit methods
@@ -101,9 +88,6 @@ void Artic_sea::assemble_system(){
     paraview_out->RegisterField("Temperature", theta);
     paraview_out->RegisterField("Salinity", phi);
     paraview_out->RegisterField("Phase", phase);
-    paraview_out->RegisterField("Stream_Function(r)", x_psi);
-    paraview_out->RegisterField("Velocity(r)", x_v);
-    paraview_out->RegisterField("Vorticity(r)", x_w);
     paraview_out->SetCycle(vis_impressions);
     paraview_out->SetTime(t);
     paraview_out->Save();
@@ -119,6 +103,7 @@ void Artic_sea::assemble_system(){
              << "Progress"
              << left << setw(12)
              << "\n--------------------------------------------------\n";
+
 }
 
 double r_f(const Vector &x){
diff --git a/code/conduction_assemble.cpp b/../double_diffusion_2/code/conduction_assemble.cpp
index 9df1c51d..014ada34 100644
--- a/code/conduction_assemble.cpp
+++ b/../double_diffusion_2/code/conduction_assemble.cpp
@@ -23,10 +23,10 @@ Conduction_Operator::Conduction_Operator(Config config, ParFiniteElementSpace &f
     t_theta(NULL), t_phi(NULL),
     M_theta_solver(fespace.GetComm()), M_phi_solver(fespace.GetComm()),
     T_theta_solver(fespace.GetComm()), T_phi_solver(fespace.GetComm()),
-    aux_theta(&fespace), aux_phi(&fespace),
+    aux_theta(&fespace), aux_phi(&fespace), 
     aux_C(&fespace), aux_K(&fespace), aux_D(&fespace),
     psi(&fespace),
-    coeff_r(r_f), zero(dim, zero_f), rot(dim, rot_f),
+    coeff_r(r_f), zero(dim, zero_f), rot(dim, rot_f), 
     gradpsi(&psi), coeff_rV(rot, zero), dt_coeff_rV(0., coeff_rV),
     coeff_rCL(coeff_r, coeff_r),
     coeff_rK(coeff_r, coeff_r), dt_coeff_rK(0., coeff_rK),
@@ -44,8 +44,8 @@ Conduction_Operator::Conduction_Operator(Config config, ParFiniteElementSpace &f
     neg_dt_r_robin_h_theta(0., neg_r_robin_h_theta), neg_dt_r_robin_h_phi(0., neg_r_robin_h_phi),
     neg_dt_r_robin_h_ref_theta(0., neg_r_robin_h_ref_theta), neg_dt_r_robin_h_ref_phi(0., neg_r_robin_h_ref_phi)
 {
-    //Set boundary conditions
-    //
+    //Define essential boundary conditions
+    //   
     //                  1
     //            /------------\
     //            |            |
@@ -53,20 +53,21 @@ Conduction_Operator::Conduction_Operator(Config config, ParFiniteElementSpace &f
     //            |            |
     //            \------------/
     //                  0
-    Array<int> ess_bdr_theta(attributes); ess_bdr_theta=0;
+
+    Array<int> ess_bdr_theta(attributes); ess_bdr_theta = 0;
     ess_bdr_theta[0] = 0;     ess_bdr_theta[1] = 0;     ess_bdr_theta[3] = 1;
     newmann_bdr_theta[0] = 0; newmann_bdr_theta[1] = 0; newmann_bdr_theta[3] = 0;
     robin_bdr_theta[0] = 0;   robin_bdr_theta[1] = 1;   robin_bdr_theta[3] = 0;
     fespace.GetEssentialTrueDofs(ess_bdr_theta, ess_tdof_list_theta);
 
     Array<int> ess_bdr_phi(attributes); ess_bdr_phi = 0;
-    ess_bdr_phi[0] = 0;       ess_bdr_phi[1] = 0;       ess_bdr_phi[3] = 1;
+    ess_bdr_phi[0] = 0;       ess_bdr_phi[1] = 0;       ess_bdr_phi[3] = 1; 
     newmann_bdr_phi[0] = 0;   newmann_bdr_phi[1] = 0;   newmann_bdr_phi[3] = 0;
     robin_bdr_phi[0] = 0;     robin_bdr_phi[1] = 1;     robin_bdr_phi[3] = 0;
     fespace.GetEssentialTrueDofs(ess_bdr_phi, ess_tdof_list_phi);
 
     //Check that the internal boundaries is always zero.
-    ess_bdr_theta[2] = 0;     ess_bdr_phi[2] = 0;
+    ess_bdr_theta[2] = 0;     ess_bdr_phi[2] = 0; 
     newmann_bdr_theta[2] = 0; newmann_bdr_phi[2] = 0;
     robin_bdr_theta[2] = 0;   robin_bdr_phi[2] = 0;
 
@@ -144,3 +145,25 @@ double newmann_theta_f(const Vector &x){
 double newmann_phi_f(const Vector &x){
     return 0;
 }
+
+double robin_h_theta_f(const Vector &x){
+    if (x(0) < entrance)
+        return -3.88*vel;
+    else
+        return 0.;
+}
+
+double robin_h_phi_f(const Vector &x){
+    if (x(0) < entrance)
+        return -vel;
+    else
+        return 0.;
+}
+
+double robin_ref_theta_f(const Vector &x){
+    return theta_out;
+}
+
+double robin_ref_phi_f(const Vector &x){
+    return phi_out;
+}
diff --git a/code/conduction_solve.cpp b/../double_diffusion_2/code/conduction_solve.cpp
index 8f9c735f..676f00c1 100644
--- a/code/conduction_solve.cpp
+++ b/../double_diffusion_2/code/conduction_solve.cpp
@@ -1,8 +1,8 @@
 #include "header.h"
 
+//Solve M(dX_dt) = -K(X) for dX_dt
 void Conduction_Operator::Mult(const Vector &X, Vector &dX_dt) const{
-    //Solve M(dX_dt) = -K(X) for dX_dt
-
+    //Initialize the corresponding vectors
     HypreParVector Theta(&fespace);
     HypreParVector Phi(&fespace);
     for (int ii = block_true_offsets[0]; ii < block_true_offsets[1]; ii++)
@@ -87,8 +87,8 @@ int Conduction_Operator::SUNImplicitSetup(const Vector &X, const Vector &B, int
     return 0;
 }
 
-//Solve the system Ax = z -> (M - gamma*K)x = Mb
-int Conduction_Operator::SUNImplicitSolve(const Vector &B, Vector &X, double tol){
+//Solve the system AX = Z -> (M + gamma*K)X = M*B
+int Conduction_Operator::SUNImplicitSolve(const Vector &B, Vector &X, double tol){    
     //Initialize the corresponding vectors
     HypreParVector B_theta(&fespace), B_phi(&fespace);
     for (int ii = block_true_offsets[0]; ii < block_true_offsets[1]; ii++)
diff --git a/code/flow_assemble.cpp b/code/flow_assemble.cpp
deleted file mode 100644
index a865ac09..00000000
--- a/code/flow_assemble.cpp
+++ /dev/null
@@ -1,203 +0,0 @@
-#include "header.h"
-
-// unitary r vector
-void r_hat(const Vector &x, Vector &y);
-
-//void r_inv_hat_f(const Vector &x, Vector &f);
-
-double r_inv(const Vector &x);
-
-//Right hand side of the equation
- double f_rhs(const Vector &x);
-
-//Boundary values for w
- double boundary_w(const Vector &x);
-
- void boundary_gradw(const Vector &x, Vector &f);
-
-//Boundary values for psi
- double boundary_psi(const Vector &x);
-
- void boundary_gradpsi(const Vector &x, Vector &f);
-
-Flow_Operator::Flow_Operator(Config config, ParFiniteElementSpace &fespace, ParFiniteElementSpace &fespace_v, int dim, int attributes, Array<int> block_true_offsets, const HypreParVector *X_T):
-  fespace(fespace),
-  f(NULL), g(NULL),
-  m(NULL), d(NULL), c(NULL),
-  M(NULL), D(NULL), C(NULL), hBlocks(2,2), H(NULL),
-  psi(NULL), w(NULL), v(NULL),
-  w_aux(NULL), psi_aux(NULL), theta(NULL),
-  bg(1.), r_invCoeff(r_inv), r_hatCoeff(dim, r_hat), r_inv_hat(r_invCoeff, r_hatCoeff),
-  neg(-1.), w_coeff(boundary_w), w_grad(dim, boundary_gradw), psi_coeff(boundary_psi),
-  psi_grad(dim, boundary_gradpsi), eta_r_inv_hat(neg, r_inv_hat), neg_w(neg, w_coeff),
-  r_inv_hat_w_grad(r_inv_hat, w_grad), neg_w_grad(neg, w_grad), r_inv_hat_psi_grad(r_inv_hat, psi_grad),
-  eta_r_inv_hat_psi_grad(eta_r_inv_hat, psi_grad), neg_psi_grad(neg, psi_grad),
-  eta_psi_grad(neg, psi_grad), neg_eta_psi_grad(neg, eta_psi_grad), inv_mu(pow(config.viscosity, -1)),
-  x_T(NULL), delta_T(x_T), rcap(dim, r_hat), r_deltaT(rcap, delta_T), bg_deltaT(bg, r_deltaT),
-  r(r_f), rF(bg_deltaT, r), inv_mu_TCoeff(inv_mu, rF),
-  ess_bdr_psi(attributes), ess_bdr_w(attributes), superlu(NULL), SLU_A(NULL)
-{
-  //Initialize the corresponding vectors
-  Y.Update(block_true_offsets);
-  B.Update(block_true_offsets);
-
-  x_T = new ParGridFunction(&fespace);
-
-  theta = new ParGridFunction(&fespace);
-  theta->SetFromTrueDofs(*X_T);
-  for (int ii = 0; ii < theta->Size(); ii++){
-      (*theta)(ii) = 0.5*(1 + tanh(5*config.invDeltaT*((*theta)(ii) - config.T_f)));
-      (*theta)(ii) = config.epsilon_eta + pow(1-(*theta)(ii), 2)/(pow((*theta)(ii), 3) + config.epsilon_eta);
-  }
-
-  //Define local coefficients
-  //Properties coefficients
-  eta.SetGridFunction(theta);
-
-  //Rotational coupled coefficients
-  eta_r_inv_hat.SetACoef(eta);
-
-  eta_r_inv_hat_psi_grad.SetACoef(eta_r_inv_hat);
-  eta_psi_grad.SetACoef(eta);
-  neg_eta_psi_grad.SetBCoef(eta_psi_grad);
-
-  //Define essential boundary conditions
-    //
-    //                  1
-    //            /------------\
-    //            |            |
-    //           2|            |3
-    //            |            |
-    //            \------------/
-    //                  0
-
-  ess_bdr_w[0] = 0; ess_bdr_w[1] = 0;
-  ess_bdr_w[2] = 1; ess_bdr_w[3] = 1;
-  fespace.GetEssentialTrueDofs(ess_bdr_w, ess_tdof_list_w);
-
-  ess_bdr_psi[0] = 0; ess_bdr_psi[1] = 0;
-  ess_bdr_psi[2] = 1; ess_bdr_psi[3] = 1;
-  fespace.GetEssentialTrueDofs(ess_bdr_psi, ess_tdof_list_psi);
-
-  //Define grid functions
-  w =  new ParGridFunction(&fespace);
-  w_aux = new ParGridFunction(&fespace);
-  w_aux->ProjectCoefficient(w_coeff);
-
-  psi = new ParGridFunction(&fespace);
-  psi_aux = new ParGridFunction(&fespace);
-  psi_aux->ProjectCoefficient(psi_coeff);
-
-  v = new ParGridFunction(&fespace_v);
-
-  g = new ParLinearForm(&fespace);
-  g->AddDomainIntegrator(new DomainLFIntegrator(neg_w));
-  g->AddDomainIntegrator(new DomainLFIntegrator(r_inv_hat_psi_grad));
-  g->AddDomainIntegrator(new DomainLFGradIntegrator(psi_grad));
-  g->AddBoundaryIntegrator(new BoundaryNormalLFIntegrator(neg_psi_grad), ess_bdr_psi);
-  g->Assemble();
-  g->ParallelAssemble(B.GetBlock(0));
-
-  this->Update_T(config, X_T, dim, attributes);
-
-  //Define bilinear forms of the system
-  m = new ParBilinearForm(&fespace);
-  m->AddDomainIntegrator(new MassIntegrator);
-  m->Assemble();
-  m->EliminateEssentialBCFromDofs(ess_tdof_list_w);
-  m->Finalize();
-  M = m->ParallelAssemble();
-
-  c = new ParMixedBilinearForm(&fespace, &fespace);
-  c->AddDomainIntegrator(new MixedGradGradIntegrator);
-  c->AddDomainIntegrator(new MixedDirectionalDerivativeIntegrator(r_inv_hat));
-  c->Assemble();
-  OperatorHandle Ch;
-  c->FormRectangularSystemMatrix(ess_tdof_list_psi, ess_tdof_list_w, Ch);
-  C = Ch.Is<HypreParMatrix>();
-}
-
-
-void Flow_Operator::Update_T(Config config, const HypreParVector *X_T, int dim, int attributes){
-  if(theta) delete theta;
-  theta = new ParGridFunction(&fespace);
-  theta->SetFromTrueDofs(*X_T);
-  for (int ii = 0; ii < theta->Size(); ii++){
-    (*theta)(ii) = 0.5*(1 + tanh(5*config.invDeltaT*((*theta)(ii) - config.T_f)));
-    (*theta)(ii) = config.epsilon_eta + pow(1-(*theta)(ii), 2)/(pow((*theta)(ii), 3) + config.epsilon_eta);
-  }
-
-  //Define local coefficients
-  //Properties coefficients
-  eta.SetGridFunction(theta);
-
-  //Rotational coupled coefficients
-  eta_r_inv_hat.SetACoef(eta);
-
-  eta_r_inv_hat_psi_grad.SetACoef(eta_r_inv_hat);
-  eta_psi_grad.SetACoef(eta);
-  neg_eta_psi_grad.SetBCoef(eta_psi_grad);
-
-  x_T->SetFromTrueDofs(*X_T);
-  delta_T.SetGridFunction(x_T);
-  r_deltaT.SetBCoef(delta_T);
-  bg_deltaT.SetBCoef(r_deltaT);
-  rF.SetACoef(bg_deltaT);
-  inv_mu_TCoeff.SetBCoef(rF);
-
-
-  if(f) delete f;
-  f = new ParLinearForm(&fespace);
-  f->AddDomainIntegrator(new DomainLFIntegrator(inv_mu_TCoeff));
-  f->AddDomainIntegrator(new DomainLFIntegrator(r_inv_hat_w_grad));
-  f->AddDomainIntegrator(new DomainLFIntegrator(eta_r_inv_hat_psi_grad));
-  f->AddDomainIntegrator(new DomainLFGradIntegrator(w_grad));
-  f->AddDomainIntegrator(new DomainLFGradIntegrator(eta_psi_grad));
-  f->AddBoundaryIntegrator(new BoundaryNormalLFIntegrator(neg_eta_psi_grad), ess_bdr_psi);
-  f->AddBoundaryIntegrator(new BoundaryNormalLFIntegrator(neg_w_grad), ess_bdr_w);
-  f->Assemble();
-  f->ParallelAssemble(B.GetBlock(1));
-
-  if(d) delete d;
-  d = new ParBilinearForm(&fespace);
-  d->AddDomainIntegrator(new DiffusionIntegrator(eta));
-  d->AddDomainIntegrator(new ConvectionIntegrator(eta_r_inv_hat));
-  d->Assemble();
-  d->EliminateEssentialBCFromDofs(ess_tdof_list_psi);
-  d->Finalize();
-  D = d->ParallelAssemble();
-}
-
-double r_inv(const Vector &x){
-  return pow(x(0) + epsilon_r, -1);
-}
-
-void r_hat(const Vector &x, Vector &y){
-  y(0)=1;
-  y(1)=0;
-}
-
-//Right hand side of the equation
-double f_rhs(const Vector &x){
-    return 0.;
-}
-
-//Boundary values for w
-double boundary_w(const Vector &x){
-    return 0;
-}
-
-void boundary_gradw(const Vector &x, Vector &f){
-    f(0) = 0;
-    f(1) = 0;
-}
-
-//Boundary values for psi
-double boundary_psi(const Vector &x){
-    return 0.5*x(0)*x(0);
-}
-
-void boundary_gradpsi(const Vector &x, Vector &f){
-    f(0) = x(0);
-    f(1) = 0;
-}
diff --git a/code/flow_solve.cpp b/code/flow_solve.cpp
deleted file mode 100644
index b44f56f2..00000000
--- a/code/flow_solve.cpp
+++ /dev/null
@@ -1,49 +0,0 @@
-#include "header.h"
-
-void Flow_Operator::Solve(Config config, const HypreParVector *X_T, int dim, int attributes){
-
-    this->Update_T(config, X_T, dim, attributes);
-
-    //Create the complete bilinear operator:
-    //
-    //   H = [ M    C ]
-    //       [ C^t  D ]
-    // Array2D<HypreParMatrix*> hBlocks(2,2);
-    // hBlocks = NULL;
-    hBlocks(0, 0) = M;
-    hBlocks(0, 1) = C;
-    hBlocks(1, 0) = C->Transpose();
-    hBlocks(1, 1) = D;
-
-    Array2D<double> blockCoeff(2,2);
-    blockCoeff(0, 0) = 1.;
-    blockCoeff(0, 1) = -1.;
-    blockCoeff(1, 0) = -1.;
-    blockCoeff(1, 1) = -1.;
-
-    H = HypreParMatrixFromBlocks(hBlocks, &blockCoeff);
-
-    if(superlu) delete superlu;
-    superlu = new SuperLUSolver(MPI_COMM_WORLD);
-    if(SLU_A) delete SLU_A;
-    SLU_A = new SuperLURowLocMatrix(*H);
-    superlu->SetOperator(*SLU_A);
-    superlu->SetPrintStatistics(true);
-    superlu->SetSymmetricPattern(true);
-    superlu->SetColumnPermutation(superlu::PARMETIS);
-    superlu->SetIterativeRefine(superlu::SLU_DOUBLE);
-
-    //Solve the linear system Ax=B
-    Y.Randomize();
-    superlu->Mult(B, Y);
-    superlu->DismantleGrid();
-
-    //Recover the solution on each proccesor
-    w->Distribute(&(Y.GetBlock(0)));
-    for (int ii = 0; ii < w->Size(); ii++)
-        (*w)(ii) += (*w_aux)(ii);
-
-    psi->Distribute(&(Y.GetBlock(1)));
-    for (int ii = 0; ii < psi->Size(); ii++)
-        (*psi)(ii) += (*psi_aux)(ii);
-}
diff --git a/code/grid.cpp b/../double_diffusion_2/code/grid.cpp
index 70942f5b..4b39fab0 100644
--- a/code/grid.cpp
+++ b/../double_diffusion_2/code/grid.cpp
@@ -26,24 +26,17 @@ void Artic_sea::make_grid(const char *mesh_file){
     for (int ii = 0; ii < config.refinements - serial_refinements; ii++)
         pmesh->UniformRefinement();
 
-    //Calculate minimum size of elements
-    double null;
-    pmesh->GetCharacteristics(h_min, null, null, null);
-
     //Create the FEM space associated with the mesh
     fec = new H1_FECollection(config.order, dim);
     fespace = new ParFiniteElementSpace(pmesh, fec);
     size = fespace->GlobalTrueVSize();
 
-    fec_v = new RT_FECollection(config.order, dim);
-    fespace_v = new ParFiniteElementSpace(pmesh, fec_v);
-    size_v = fespace_v->GlobalTrueVSize();
-
     //Create the block offsets
     block_true_offsets[0] = 0;
     block_true_offsets[1] = fespace->TrueVSize();
     block_true_offsets[2] = fespace->TrueVSize();
     block_true_offsets.PartialSum();
 
+    //Initialize the corresponding vectors
     X.Update(block_true_offsets);
 }
diff --git a/code/header.h b/../double_diffusion_2/code/header.h
index 0f65c1b8..1aa2d0a2 100644
--- a/code/header.h
+++ b/../double_diffusion_2/code/header.h
@@ -32,9 +32,8 @@ struct Config{
     double invDeltaT;
     double c_l, c_s;
     double k_l, k_s;
+    double D_l, D_s;
     double L;
-    double viscosity;
-    double epsilon_eta;
 };
 
 class Conduction_Operator : public TimeDependentOperator{
@@ -42,10 +41,9 @@ class Conduction_Operator : public TimeDependentOperator{
         Conduction_Operator(Config config, ParFiniteElementSpace &fespace, int dim, int attributes, Array<int> block_true_offsets, BlockVector &X);
 
         void SetParameters(const BlockVector &X);
-        void UpdateVelocity(const HypreParVector &psi, ParGridFunction *v);
+        void UpdateVelocity(const Vector &psi);
 
         virtual void Mult(const Vector &X, Vector &dX_dt) const;    //Solver for explicit methods
-        //virtual void ImplicitSolve(const double dt, const Vector &X, Vector &dX_dt); //Solver for implicit methods
         virtual int SUNImplicitSetup(const Vector &X, const Vector &B, int j_update, int *j_status, double scaled_dt);
 	    virtual int SUNImplicitSolve(const Vector &B, Vector &X, double tol);
 
@@ -54,6 +52,7 @@ class Conduction_Operator : public TimeDependentOperator{
         //Global parameters
         Config config;
 
+        //Mesh objects
         ParFiniteElementSpace &fespace;
         Array<int> block_true_offsets;
 
@@ -67,9 +66,8 @@ class Conduction_Operator : public TimeDependentOperator{
         ParBilinearForm *k_theta, *k_phi;        //Difussion operators
         ParBilinearForm *t_theta, *t_phi;        //m + dt*k
 
-
         HypreParMatrix M_theta, M_phi;
-        HypreParMatrix T_theta, T_phi;
+        HypreParMatrix T_theta, T_phi;   
 
         //Solver objects
         CGSolver M_theta_solver, M_phi_solver;
@@ -99,7 +97,7 @@ class Conduction_Operator : public TimeDependentOperator{
         ProductCoefficient coeff_rK; 
         ProductCoefficient dt_coeff_rK;
 
-        ProductCoefficient coeff_rD;
+        ProductCoefficient coeff_rD; 
         ProductCoefficient dt_coeff_rD;
 
         ScalarVectorProductCoefficient coeff_rCLV;
@@ -119,93 +117,6 @@ class Conduction_Operator : public TimeDependentOperator{
         mutable ProductCoefficient neg_dt_r_robin_h_ref_theta, neg_dt_r_robin_h_ref_phi;
 };
 
-class Flow_Operator{
-  public:
-    Flow_Operator(Config config, ParFiniteElementSpace &fespace, ParFiniteElementSpace &fespace_v, int dim, int attributes, Array<int> block_true_offsets, const HypreParVector *X_T);
-    void Solve(Config config, const HypreParVector *X_T, int dim, int attributes);
-    void Update_T(Config config, const HypreParVector *X_T, int dim, int attributes);
-    ParGridFunction GetStream(){return *psi;}
-    ParGridFunction GetVelocity(){return *v;}
-    ParGridFunction GetVorticity(){return *w;}
-    ~Flow_Operator();
-
-  protected:
-
-        //Mesh objects
-        ParFiniteElementSpace &fespace;
-
-        //System objects
-        ParLinearForm *f;
-        ParLinearForm *g;
-        ParBilinearForm *m;
-        ParBilinearForm *d;
-        ParMixedBilinearForm *c;
-        ParMixedBilinearForm *ct;
-        Array<int> ess_bdr_psi;
-        Array<int> ess_bdr_w;
-        Array<int> ess_tdof_list_w;
-        Array<int> ess_tdof_list_psi;
-
-        //Solver objects
-        ParGridFunction *psi;
-        ParGridFunction *w;
-        ParGridFunction *v;
-        BlockVector Y;
-        BlockVector B;
-        HypreParMatrix *M;
-        HypreParMatrix *D;
-        HypreParMatrix *C;
-        Array2D<HypreParMatrix*> hBlocks;
-        HypreParMatrix *H;
-
-       //Boundary conditions
-       ParGridFunction *w_aux;
-       ParGridFunction *psi_aux;
-       ParGridFunction *theta;
-
-       ConstantCoefficient bg;
-       //Rotational coefficients
-       FunctionCoefficient r_invCoeff;
-       VectorFunctionCoefficient r_hatCoeff;
-       ScalarVectorProductCoefficient r_inv_hat;
-       //Properties coefficients
-       GridFunctionCoefficient eta;
-       ConstantCoefficient neg;
-       //Dirichlet coefficients
-       FunctionCoefficient w_coeff;
-       VectorFunctionCoefficient w_grad;
-
-       FunctionCoefficient psi_coeff;
-       VectorFunctionCoefficient psi_grad;
-       //Rotational coupled coefficients
-       ScalarVectorProductCoefficient eta_r_inv_hat;
-
-       ProductCoefficient neg_w;
-       InnerProductCoefficient r_inv_hat_w_grad;
-       ScalarVectorProductCoefficient neg_w_grad;
-
-       InnerProductCoefficient r_inv_hat_psi_grad;
-       InnerProductCoefficient eta_r_inv_hat_psi_grad;
-       ScalarVectorProductCoefficient neg_psi_grad;
-       ScalarVectorProductCoefficient eta_psi_grad;
-       ScalarVectorProductCoefficient neg_eta_psi_grad;
-       //Temperature coefficients
-       ConstantCoefficient inv_mu;
-       ParGridFunction *x_T;
-       GradientGridFunctionCoefficient delta_T;
-       VectorFunctionCoefficient rcap;
-       InnerProductCoefficient r_deltaT;
-       ProductCoefficient bg_deltaT;
-       FunctionCoefficient r;
-       ProductCoefficient rF;
-       ProductCoefficient inv_mu_TCoeff;
-
-       //Solver objects
-       SuperLUSolver *superlu;
-       Operator *SLU_A;
-
-};
-
 class Artic_sea{
     public:
         Artic_sea(Config config);
@@ -229,22 +140,17 @@ class Artic_sea{
         int vis_impressions;
 
         int dim;
-        double h_min;
         int serial_refinements;
         HYPRE_Int size;
-        HYPRE_Int size_v;
 
         ParMesh *pmesh;
         FiniteElementCollection *fec;
-        FiniteElementCollection *fec_v;
         ParFiniteElementSpace *fespace;
-        ParFiniteElementSpace *fespace_v;
 
         Array<int> block_true_offsets;
 
         //System objects
         ParGridFunction *theta;
-        HypreParVector *Theta;
         ParGridFunction *phi;
         ParGridFunction *phase;
 
@@ -257,13 +163,6 @@ class Artic_sea{
         ARKStepSolver *arkode;
 
         ParaViewDataCollection *paraview_out;
-
-        //Flow_Operator objects
-        Flow_Operator *flow_oper;
-        ParGridFunction *x_psi;
-        ParGridFunction *x_v;
-        ParGridFunction *x_w;
-        HypreParVector *X_Psi;
 };
 
 extern double r_f(const Vector &x);
@@ -274,7 +173,6 @@ extern double T_fun(const double &salinity);
 
 extern double delta_c_s_fun(const double &temperature, const double &salinity);
 
-extern double Rmin, Rmax, Zmin, Zmax, height;
-extern double epsilon_r;
+extern double Rmin, Rmax, Zmin, Zmax;
 
 extern double mid;
diff --git a/code/main.cpp b/../double_diffusion_2/code/main.cpp
index 79be72fe..358154a2 100644
--- a/code/main.cpp
+++ b/../double_diffusion_2/code/main.cpp
@@ -5,13 +5,9 @@ double Rmin;
 double Zmin;
 double Rmax;
 double Zmax;
-double height;
 
 double mid;
 
-//Size of the BC border
-double epsilon_r;
-
 int main(int argc, char *argv[]){
     //Define MPI parameters
     int nproc = 0, pid = 0;
@@ -22,7 +18,7 @@ int main(int argc, char *argv[]){
     //Define program paramenters
     const char *mesh_file;
     Config config((pid == 0), nproc);
-    int nDeltaT, nEpsilon_eta, nEpsilon_r;
+    int nDeltaT = 0;
 
     OptionsParser args(argc, argv);
     args.AddOption(&mesh_file, "-m", "--mesh",
@@ -73,15 +69,12 @@ int main(int argc, char *argv[]){
                    "Liquid thermal conductivity.");
     args.AddOption(&config.k_s, "-k_s", "--k_s",
                    "Solid thermal conductivity.");
+    args.AddOption(&config.D_l, "-D_l", "--D_l",
+                   "Liquid diffusion constant.");
+    args.AddOption(&config.D_s, "-D_s", "--D_s",
+                   "Solid diffusion constant.");
     args.AddOption(&config.L, "-L", "--L",
                    "Volumetric latent heat.");
-    args.AddOption(&config.viscosity, "-v", "--viscosity",
-                   "Kinematic viscosity of the material.");
-    args.AddOption(&nEpsilon_eta, "-e_eta", "--epsilon_eta",
-                   "Value of constatn epsilon for (1-phi)^2/(phi^3 + epsilon)(10^(-n)).");
-    args.AddOption(&nEpsilon_r, "-e_r", "--epsilon_r",
-                   "Value of constant epsilon for 1/(r + epsilon) (10^(-n)).");
-
 
     //Check if parameters were read correctly
     args.Parse();
@@ -92,13 +85,12 @@ int main(int argc, char *argv[]){
     }
     if (config.master) args.PrintOptions(cout);
 
-    height = Zmax - Zmin;
-    config.invDeltaT = pow(10, nDeltaT);
-    config.epsilon_eta = pow(10, -nEpsilon_eta);
-    epsilon_r = pow(10, -nEpsilon_r);
+    //Run the program for different refinements
     mid = Zmax*config.k_s/(config.k_s + config.k_l);
+    
+    config.invDeltaT = pow(10, nDeltaT);
     Artic_sea artic_sea(config);
-    artic_sea.run(mesh_file);
+    artic_sea.run(mesh_file); 
 
     MPI_Finalize();
 
diff --git a/code/output.cpp b/../double_diffusion_2/code/output.cpp
index d180d50b..4b60dcb6 100644
--- a/code/output.cpp
+++ b/../double_diffusion_2/code/output.cpp
@@ -3,9 +3,7 @@
 void Artic_sea::output_results(){
     //Print general information of the program
     if (config.master)
-        cout << "\n\nSize: " << size << "\n"
-             << "Vectorial size: " << size_v << "\n"
-             << "Mesh Size: " << h_min << "\n"
+        cout << "\n\nSize: " << 2*size << "\n"
              << "Serial refinements: " << serial_refinements << "\n"
              << "Parallel refinements: " << config.refinements - serial_refinements << "\n"
              << "Total refinements: " << config.refinements << "\n"
diff --git a/code/run.cpp b/../double_diffusion_2/code/run.cpp
index 6d1d0b86..fb0abb93 100644
--- a/code/run.cpp
+++ b/../double_diffusion_2/code/run.cpp
@@ -7,13 +7,12 @@ Config::Config(bool master, int nproc):
 
 Artic_sea::Artic_sea(Config config):
     config(config),
-    pmesh(NULL), fec(NULL), fec_v(NULL), fespace(NULL), fespace_v(NULL),
+    pmesh(NULL), fec(NULL), fespace(NULL),
     block_true_offsets(3),
-    theta(NULL), phi(NULL), phase(NULL), Theta(NULL),
+    theta(NULL), phi(NULL), phase(NULL),
     oper_T(NULL),
     ode_solver(NULL), cvode(NULL), arkode(NULL),
-    paraview_out(NULL), flow_oper(NULL), x_psi(NULL), x_v(NULL), x_w(NULL),
-    X_Psi(NULL)
+    paraview_out(NULL)
 {}
 
 void Artic_sea::run(const char *mesh_file){
@@ -27,49 +26,23 @@ void Artic_sea::run(const char *mesh_file){
 
 Conduction_Operator::~Conduction_Operator(){
     //Delete used memory
-    delete m_theta;
+    delete m_theta; 
     delete m_phi;
     delete k_theta;
     delete k_phi;
-    delete t_theta;
+    delete t_theta; 
     delete t_phi;
 }
 
-Flow_Operator::~Flow_Operator(){
-    delete f;
-    delete g;
-    delete m;
-    delete d;
-    delete c;
-    delete M;
-    delete D;
-    delete psi;
-    delete w;
-    delete v;
-    delete psi_aux;
-    delete w_aux;
-    delete theta;
-    delete x_T;
-    delete H;
-}
-
 Artic_sea::~Artic_sea(){
     delete pmesh;
     delete fec;
     delete fespace;
-    delete fec_v;
-    delete fespace_v;
     delete theta;
     delete phi;
     delete phase;
-    delete Theta;
     delete oper_T;
     delete ode_solver;
     delete paraview_out;
-    delete flow_oper;
-    delete x_psi;
-    delete x_v;
-    delete x_w;
-    delete X_Psi;
     if (config.master) cout << "Memory deleted \n";
 }
diff --git a/code/step.cpp b/../double_diffusion_2/code/step.cpp
index 53d9a07c..538d3b91 100644
--- a/code/step.cpp
+++ b/../double_diffusion_2/code/step.cpp
@@ -9,17 +9,6 @@ void Artic_sea::time_step(){
     oper_T->SetParameters(X);
     ode_solver->Step(X, t, dt);
 
-    //Solve the flow problem
-    X_Psi = (flow_oper->GetStream()).GetTrueDofs();
-    theta->Distribute(&(X.GetBlock(0)));
-    Theta = theta->GetTrueDofs();
-
-    flow_oper->Solve(config, Theta, dim, pmesh->bdr_attributes.Max());
-    (*x_psi) = flow_oper->GetStream();
-    (*x_w) = flow_oper->GetVorticity();
-
-    oper_T->UpdateVelocity(*X_Psi, x_v);
-
     //Update visualization steps
     vis_steps = (dt == config.dt_init) ? config.vis_steps_max : int((config.dt_init/dt)*config.vis_steps_max);
 
@@ -28,8 +17,17 @@ void Artic_sea::time_step(){
         vis_iteration = 0;
         vis_impressions++;
 
-        //Graph
+        //Read system state
+        theta->Distribute(&(X.GetBlock(0)));
         phi->Distribute(&(X.GetBlock(1)));
+
+        //Calculate phases
+        for (int ii = 0; ii < phase->Size(); ii++){
+            double T_f = config.T_f + T_fun((*phi)(ii));
+            (*phase)(ii) = 0.5*(1 + tanh(5*config.invDeltaT*((*theta)(ii) - T_f)));
+        }
+
+        //Graph
         paraview_out->SetCycle(vis_impressions);
         paraview_out->SetTime(t);
         paraview_out->Save();
@@ -66,7 +64,6 @@ void Conduction_Operator::SetParameters(const BlockVector &X){
             aux_K(ii) = config.k_s;
             aux_D(ii) = config.D_s;
         }
-
         aux_theta(ii) = config.L*config.invDeltaT*exp(-M_PI*pow(config.invDeltaT*(aux_theta(ii) - T_f), 2));
     }
 
@@ -79,9 +76,9 @@ void Conduction_Operator::SetParameters(const BlockVector &X){
     SumCoefficient coeff_CL(coeff_C, coeff_L);
     coeff_rCL.SetBCoef(coeff_CL);
 
-    coeff_rK.SetBCoef(coeff_K); dt_coeff_rK.SetBCoef(coeff_rK);
+    coeff_rK.SetBCoef(coeff_K); dt_coeff_rK.SetBCoef(coeff_rK); 
 
-    coeff_rD.SetBCoef(coeff_D); dt_coeff_rD.SetBCoef(coeff_rD);
+    coeff_rD.SetBCoef(coeff_D); dt_coeff_rD.SetBCoef(coeff_rD); 
 
     coeff_rCLV.SetACoef(coeff_CL);
     dt_coeff_rCLV.SetBCoef(coeff_rCLV);
@@ -118,12 +115,10 @@ void Conduction_Operator::SetParameters(const BlockVector &X){
     k_phi->Finalize();
 }
 
-void Conduction_Operator::UpdateVelocity(const HypreParVector &Psi, ParGridFunction *v){
+void Conduction_Operator::UpdateVelocity(const Vector &Psi){
     psi.SetFromTrueDofs(Psi);
     gradpsi.SetGridFunction(&psi);
     coeff_rV.SetBCoef(gradpsi);
-    v->Randomize();
-    v->ProjectDiscCoefficient(coeff_rV, GridFunction::ARITHMETIC);
     dt_coeff_rV.SetBCoef(coeff_rV);
     coeff_rCLV.SetBCoef(coeff_rV);
 }
